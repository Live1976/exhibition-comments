<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>You're Live to the World - Admin Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: #000;
            color: #fff;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 24px;
            font-weight: 400;
        }

        .login-section {
            background: white;
            padding: 40px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
            margin: 100px auto;
        }

        .login-section h2 {
            margin-bottom: 20px;
            font-weight: 400;
            text-align: center;
        }

        .admin-panel {
            display: none;
        }

        .comment-controls {
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .filter-btn {
            padding: 8px 16px;
            background: #f5f5f5;
            color: #333;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .filter-btn.active {
            background: #007cba;
            color: white;
            border-color: #007cba;
        }

        .filter-btn:hover {
            background: #e0e0e0;
        }

        .filter-btn.active:hover {
            background: #005a8b;
        }

        .ai-analysis {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #b3d9ff;
        }

        .ai-analysis h3 {
            margin-bottom: 15px;
            color: #0066cc;
        }

        .prompt-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .prompt-stat {
            background: white;
            padding: 8px 12px;
            border-radius: 3px;
            border: 1px solid #ccc;
            font-size: 12px;
        }

        .prompt-type {
            font-weight: bold;
            color: #0066cc;
        }

        .ai-comment-item {
            border-left: 4px solid #4CAF50;
        }

        .human-comment-item {
            border-left: 4px solid #2196F3;
        }

        .comment-meta {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .comment-list {
            margin-top: 20px;
        }

        .comment-item {
            background: white;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: relative;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .comment-author {
            font-weight: 500;
        }

        .comment-time {
            color: #999;
            font-size: 14px;
        }

        .comment-content {
            margin-bottom: 15px;
        }

        .comment-actions {
            text-align: right;
        }

        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .approve-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
        }

        .pending {
            background: #fffde7;
        }

        .pending::before {
            content: "PENDING REVIEW";
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff9800;
            color: white;
            padding: 3px 8px;
            font-size: 12px;
            border-radius: 3px;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            padding: 12px 20px;
            background: #000;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .logout-btn {
            background: transparent;
            border: 1px solid white;
            width: auto;
            font-size: 14px;
            padding: 5px 10px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            text-align: center;
        }
        
        .stat-number {
            font-size: 36px;
            font-weight: 300;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        
        .ai-section {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .ai-section h2 {
            margin-bottom: 20px;
            font-weight: 400;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .save-btn {
            width: auto;
            margin-right: 10px;
        }

        .ai-preview {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            border: 1px solid #eee;
            min-height: 50px;
        }

        .ai-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .ai-controls button {
            width: auto;
            padding: 10px 15px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .frequency-setting {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .frequency-setting h3 {
            margin-bottom: 10px;
            color: #1976d2;
        }

        .randomness-info {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .randomness-info h4 {
            color: #2e7d32;
            margin-bottom: 8px;
        }

        .fix-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .fix-notice h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        @media (max-width: 768px) {
            .ai-controls {
                flex-direction: column;
            }
            
            .ai-controls button {
                width: 100%;
            }
            
            .filter-buttons {
                flex-direction: column;
            }
            
            .prompt-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Login Section -->
    <div class="login-section" id="loginSection">
        <h2>ADMIN LOGIN</h2>
        <form id="loginForm">
            <input type="text" id="username" placeholder="Username" required>
            <input type="password" id="password" placeholder="Password" required>
            <button type="submit">LOGIN</button>
        </form>
    </div>

    <!-- Admin Panel -->
    <div class="admin-panel" id="adminPanel">
        <header>
            <h1>YOU'RE LIVE TO THE WORLD - ADMIN</h1>
            <button class="logout-btn" id="logoutBtn">LOGOUT</button>
        </header>
        
        <div class="container">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalComments">0</div>
                    <div class="stat-label">TOTAL COMMENTS</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="pendingComments">0</div>
                    <div class="stat-label">PENDING REVIEW</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="aiGenerated">0</div>
                    <div class="stat-label">AI GENERATED</div>
                </div>
            </div>
            
            <div class="comment-controls">
                <div class="filter-buttons">
                    <button id="showAll" class="filter-btn active">Show All Comments</button>
                    <button id="showAI" class="filter-btn">AI Comments Only</button>
                    <button id="showHuman" class="filter-btn">Human Comments Only</button>
                </div>
                <div class="ai-analysis" id="aiAnalysis" style="display: none;">
                    <!-- AI analysis will appear here -->
                </div>
            </div>
            
            <div class="comment-list" id="commentList">
                <!-- Comments will be loaded here -->
            </div>
            
            <div class="ai-section">
                <h2>Fixed AI Comment Generation System</h2>

                <div class="fix-notice">
                    <h4>Issues Fixed:</h4>
                    <p>✅ Removed self-identification phrases ("As a student...", "As someone who...")</p>
                    <p>✅ Fixed incomplete sentences that cut off mid-thought</p>
                    <p>✅ Enhanced sentence completion checking</p>
                    <p>✅ More natural visitor language while maintaining sophistication</p>
                </div>
                
                <div class="control-group">
                    <label>OpenAI API Key:</label>
                    <input type="password" id="openaiApiKey" placeholder="sk-...">
                </div>

                <div class="randomness-info">
                    <h4>Enhanced Randomness Features:</h4>
                    <p>• 20 refined prompt templates (no self-referential language)</p>
                    <p>• 35 emotional/contextual backgrounds</p>
                    <p>• 5 visitor persona types (expressed through language style, not identity)</p>
                    <p>• 6 temporal contexts (early visit, rushed viewing, etc.)</p>
                    <p>• Dynamic AI parameters (temperature 0.75-1.0, tokens 80-100)</p>
                    <p>• Sentence completion validation</p>
                </div>

                <div class="frequency-setting">
                    <h3>Auto-Generation Settings</h3>
                    <p>Current: Every 15-25 minutes (3-4 comments per hour)</p>
                    <p>Exhibition Schedule: 5 days × 8 hours × ~20 comments = ~100 total comments</p>
                    <p>Fixed system ensures natural, complete responses</p>
                </div>

                <div class="ai-controls">
                    <button id="generatePreview" class="save-btn">Generate Preview</button>
                    <button id="generateBatch" class="save-btn">Generate 5 Comments</button>
                    <button id="enableAiComments" style="background: #4CAF50;">Enable Auto Generation</button>
                    <button id="testDiversity" class="save-btn">Test Diversity (10 samples)</button>
                </div>
                
                <div class="ai-preview" id="aiPreview">
                    AI-generated comments will appear here...
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC_9YXNAYdFjmqK2iNKrra76zd05Nd61Iw",
            authDomain: "exhibition-comments.firebaseapp.com",
            projectId: "exhibition-comments",
            storageBucket: "exhibition-comments.firebasestorage.app",
            messagingSenderId: "166867670609",
            appId: "1:166867670609:web:7e2009858a5e4ecd300a70",
            measurementId: "G-D89J84MCH6"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Admin credentials
        const ADMIN_USERNAME = "admin";
        const ADMIN_PASSWORD = "password123";

        // DOM elements
        const loginSection = document.getElementById('loginSection');
        const adminPanel = document.getElementById('adminPanel');
        const loginForm = document.getElementById('loginForm');
        const logoutBtn = document.getElementById('logoutBtn');
        const commentList = document.getElementById('commentList');
        const openaiApiKey = document.getElementById('openaiApiKey');
        const generatePreview = document.getElementById('generatePreview');
        const generateBatch = document.getElementById('generateBatch');
        const enableAiComments = document.getElementById('enableAiComments');
        const testDiversity = document.getElementById('testDiversity');
        const aiPreview = document.getElementById('aiPreview');
        const showAll = document.getElementById('showAll');
        const showAI = document.getElementById('showAI');
        const showHuman = document.getElementById('showHuman');
        const aiAnalysis = document.getElementById('aiAnalysis');

        // Enhanced visitor names - more realistic contemporary art audience
        const visitorNames = [
            "Anna", "James", "Sarah", "M", "Alex", "Claire", "Tom", "L.", "Emma", "David",
            "K", "Sophie", "Ben", "R.", "Lucy", "visitor_23", "Maya", "Sam", "E.", "Chris",
            "Nina", "J.", "Zoe", "Daniel", "A.", "Rose", "Max", "F.", "Lily", "Jack",
            "Ava", "Oliver", "Grace", "P.", "Mia", "visitor_47", "Ethan", "Chloe", "H.", "Leo"
        ];

        // Visitor persona system for enhanced diversity
        const visitorPersonas = [
            { 
                type: "art_student", 
                background: "studies contemporary art, familiar with theory",
                language: "theoretical but personal"
            },
            { 
                type: "professional", 
                background: "works in creative industries, experienced gallery visitor",
                language: "informed but accessible"
            },
            { 
                type: "academic", 
                background: "teaches or researches art, critical perspective",
                language: "analytical with cultural references"
            },
            { 
                type: "curious_public", 
                background: "interested in art but not expert, open-minded",
                language: "honest and questioning"
            },
            { 
                type: "collector", 
                background: "collects contemporary art, market-aware",
                language: "evaluative with aesthetic focus"
            }
        ];

        // Temporal contexts for situational variety
        const timeContexts = [
            "early_visit", "midday_reflection", "end_of_day", 
            "repeat_visitor", "rushed_viewing", "contemplative_moment"
        ];

        // AI generation state with randomized timing
        let aiInterval = null;
        let aiGeneratedCount = 0;
        let lastPromptUsed = null;
        let usedPrompts = [];

        // Global variables for filtering
        let allComments = [];
        let currentFilter = 'all';

        // Expanded emotional/contextual backgrounds (35 items)
        const realVisitorReactions = [
            "feels like walking through someone's private memory",
            "the uncomfortable intimacy of watching domestic life",
            "caught between being a visitor and a voyeur",
            "everything looks familiar but somehow staged",
            "like peering through windows I shouldn't see",
            "the space holds its breath waiting for something",
            "domestic life as performance art",
            "boundaries between public and private dissolve here",
            "the uncanny feeling of home that isn't home",
            "surveillance made visible and visceral",
            "like being inside a social media post",
            "time feels different in these miniature worlds",
            "the scaffolding reminds me everything is constructed",
            "privacy doesn't exist in this digital fishbowl",
            "feels both intimate and completely artificial",
            "like watching life through a screen, but real",
            "the weight of being observed while observing",
            "domestic space as a stage set for invisible audiences",
            "technology making the invisible infrastructure visible",
            "the loneliness of connected life",
            "performativity of everyday actions",
            "home as both sanctuary and prison",
            "the anxiety of constant visibility",
            "miniature worlds revealing macro concerns",
            "digital life's uncanny valley",
            "the choreography of ordinary gestures",
            "surveillance capitalism made tangible",
            "the politics of domestic space",
            "intimacy mediated through technology",
            "the labor of maintaining appearances",
            "home as content production site",
            "the exhaustion of perpetual performance",
            "private life as public spectacle",
            "the architecture of attention",
            "domestic space in the age of platforms"
        ];

        // Updated prompt templates - removed self-referential language
        const promptTemplates = [
            {
                type: "phenomenological_observation",
                template: `Write about the physical experience of moving through this exhibition space. Focus on what you feel and sense as you encounter the miniature domestic environments on scaffolding and the live performances.`
            },
            {
                type: "digital_domesticity_reflection",
                template: `Reflect on how this exhibition makes you think about your own relationship to home and digital life. Consider the tension between private space and public performance that the work presents.`
            },
            {
                type: "surveillance_recognition",
                template: `Comment on how the exhibition reveals or makes you aware of surveillance, observation, and visibility in contemporary domestic life. Focus on what you notice about watching and being watched.`
            },
            {
                type: "materiality_infrastructure",
                template: `Observe the physical construction of the work - the scaffolding, cables, screens, and technical apparatus. Comment on how this visible infrastructure relates to the themes of the exhibition.`
            },
            {
                type: "uncanny_familiarity",
                template: `Write about the uncanny or unsettling feelings the exhibition generates. Focus on what feels familiar yet strange about the domestic spaces presented.`
            },
            {
                type: "performance_reality",
                template: `Comment on the live green screen performances and what they reveal about performing domesticity. Consider what it means to watch someone inhabit digital domestic spaces.`
            },
            {
                type: "scale_perspective",
                template: `Reflect on the miniature scale of the domestic environments and how this affects your viewing experience. Consider what this perspective reveals about intimacy and observation.`
            },
            {
                type: "social_media_critique",
                template: `Connect the work to your experience of homes and domestic life as seen through social media and digital platforms. Comment on the relationship between curated domesticity and lived experience.`
            },
            {
                type: "temporal_disorientation",
                template: `Write about the sense of time in the exhibition - the looping videos, repetitive actions, or how time feels different in these constructed spaces.`
            },
            {
                type: "architectural_psychology",
                template: `Comment on how the spatial design and architecture of the exhibition affects your psychological state or emotional response.`
            },
            {
                type: "collective_individual",
                template: `Reflect on the tension between individual privacy and collective visibility that the exhibition explores. Consider what "You're Live to the World" means for contemporary life.`
            },
            {
                type: "labor_domesticity",
                template: `Comment on how the exhibition reveals the work and labor involved in maintaining domestic life, especially as it becomes visible through digital platforms.`
            },
            {
                type: "authenticity_simulation",
                template: `Write about the relationship between authentic and simulated domesticity that you observe in the exhibition. Consider what feels real or artificial.`
            },
            {
                type: "intimacy_distance",
                template: `Reflect on the paradoxical experience of feeling both close to and distant from the domestic spaces presented in the exhibition.`
            },
            {
                type: "technological_mediation",
                template: `Comment on the role of technology in the exhibition and how it reveals the technological mediation of contemporary domestic experience.`
            },
            {
                type: "immediate_response",
                template: `Write an immediate, gut reaction to what you're experiencing. Focus on your first impressions and instinctive responses to the work.`
            },
            {
                type: "comparative_observation",
                template: `The exhibition reminds you of other art, media, or cultural phenomena. Comment on these connections without extensive analysis.`
            },
            {
                type: "emotional_recognition",
                template: `The exhibition has triggered a personal recognition or emotional response. Write about this feeling without being overly analytical.`
            },
            {
                type: "technical_fascination",
                template: `Comment on your curiosity about how the exhibition works technically - the green screen, the construction, the digital systems.`
            },
            {
                type: "cultural_resonance",
                template: `The exhibition connects to broader concerns about contemporary society, technology, or culture. Comment on these connections concisely.`
            }
        ];

        // Login functionality
        loginForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
                loginSection.style.display = 'none';
                adminPanel.style.display = 'block';
                loadComments();
                
                // Load saved API key
                const savedApiKey = localStorage.getItem('openaiApiKey');
                if (savedApiKey) {
                    openaiApiKey.value = savedApiKey;
                }
            } else {
                alert('Invalid credentials');
            }
        });

        // Logout functionality
        logoutBtn.addEventListener('click', function() {
            loginSection.style.display = 'block';
            adminPanel.style.display = 'none';
            document.getElementById('loginForm').reset();
        });

        // Load comments with filtering capability
        function loadComments(filter = 'all') {
            db.collection('comments')
                .orderBy('timestamp', 'desc')
                .get()
                .then(snapshot => {
                    if (snapshot.empty) {
                        commentList.innerHTML = '<p style="text-align: center; padding: 20px;">No comments yet.</p>';
                        return;
                    }
                    
                    // Store all comments
                    allComments = [];
                    snapshot.forEach(doc => {
                        allComments.push({
                            id: doc.id,
                            ...doc.data()
                        });
                    });
                    
                    // Apply filter and render
                    renderComments(filter);
                    updateStats();
                    
                    if (filter === 'ai') {
                        showAIAnalysis();
                    } else {
                        aiAnalysis.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error loading comments:', error);
                    commentList.innerHTML = `<p>Error loading comments: ${error.message}</p>`;
                });
        }

        // Render comments based on filter
        function renderComments(filter) {
            let filteredComments = allComments;
            
            if (filter === 'ai') {
                filteredComments = allComments.filter(comment => comment.isAi);
            } else if (filter === 'human') {
                filteredComments = allComments.filter(comment => !comment.isAi);
            }
            
            if (filteredComments.length === 0) {
                const filterText = filter === 'ai' ? 'AI' : filter === 'human' ? 'human' : '';
                commentList.innerHTML = `<p style="text-align: center; padding: 20px;">No ${filterText} comments yet.</p>`;
                return;
            }
            
            let html = '';
            filteredComments.forEach(comment => {
                const timestamp = comment.timestamp ? comment.timestamp.toDate() : new Date();
                const formattedTime = formatTime(timestamp);
                const commentClass = comment.isAi ? 'ai-comment-item' : 'human-comment-item';
                
                html += `
                    <div class="comment-item ${comment.status === 'pending' ? 'pending' : ''} ${commentClass}">
                        <div class="comment-header">
                            <div class="comment-author">${comment.name}</div>
                            <div class="comment-time">${formattedTime}</div>
                        </div>
                        <div class="comment-content">${comment.text || comment.content}</div>
                        ${comment.isAi && comment.promptType ? `<div class="comment-meta">AI Generated • Type: ${comment.promptType.replace(/_/g, ' ')} • Persona: ${comment.visitorPersona || 'unknown'}</div>` : ''}
                        ${!comment.isAi ? '<div class="comment-meta">Human Generated</div>' : ''}
                        <div class="comment-actions">
                            ${comment.status === 'pending' ? `<button class="approve-btn" data-id="${comment.id}">APPROVE</button>` : ''}
                            <button class="delete-btn" data-id="${comment.id}">DELETE</button>
                        </div>
                    </div>
                `;
            });
            
            commentList.innerHTML = html;
            
            // Add event listeners to buttons
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    deleteComment(this.dataset.id);
                });
            });
            
            document.querySelectorAll('.approve-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    approveComment(this.dataset.id);
                });
            });
        }

        // Show AI analysis
        function showAIAnalysis() {
            const aiComments = allComments.filter(comment => comment.isAi);
            
            if (aiComments.length === 0) {
                aiAnalysis.innerHTML = '<p>No AI comments to analyze yet.</p>';
                aiAnalysis.style.display = 'block';
                return;
            }
            
            // Count prompt types
            const promptStats = {};
            const personaStats = {};
            aiComments.forEach(comment => {
                const type = comment.promptType || 'unknown';
                const persona = comment.visitorPersona || 'unknown';
                promptStats[type] = (promptStats[type] || 0) + 1;
                personaStats[persona] = (personaStats[persona] || 0) + 1;
            });
            
            // Generate analysis HTML
            let analysisHTML = `
                <h3>Fixed AI Comments Analysis</h3>
                <p><strong>Total AI Comments:</strong> ${aiComments.length}</p>
                <p><strong>Different Prompt Types Used:</strong> ${Object.keys(promptStats).length}</p>
                <p><strong>Different Personas Used:</strong> ${Object.keys(personaStats).length}</p>
                <div class="prompt-stats">
            `;
            
            Object.entries(promptStats)
                .sort(([,a], [,b]) => b - a)
                .forEach(([type, count]) => {
                    const percentage = ((count / aiComments.length) * 100).toFixed(1);
                    analysisHTML += `
                        <div class="prompt-stat">
                            <div class="prompt-type">${type.replace(/_/g, ' ')}</div>
                            <div>${count} comments (${percentage}%)</div>
                        </div>
                    `;
                });
            
            analysisHTML += '</div><h4 style="margin-top: 15px;">Visitor Personas Distribution:</h4><div class="prompt-stats">';
            
            Object.entries(personaStats)
                .sort(([,a], [,b]) => b - a)
                .forEach(([persona, count]) => {
                    const percentage = ((count / aiComments.length) * 100).toFixed(1);
                    analysisHTML += `
                        <div class="prompt-stat">
                            <div class="prompt-type">${persona.replace(/_/g, ' ')}</div>
                            <div>${count} comments (${percentage}%)</div>
                        </div>
                    `;
                });
            
            analysisHTML += '</div>';
            
            // Add recent AI comments preview
            const recentAI = aiComments.slice(0, 5);
            analysisHTML += '<h4 style="margin-top: 15px; margin-bottom: 10px;">Recent Fixed AI Comments:</h4>';
            recentAI.forEach((comment, index) => {
                analysisHTML += `<div style="margin-bottom: 8px; font-size: 13px;"><strong>${index + 1}.</strong> [${comment.promptType}|${comment.visitorPersona}] ${comment.text}</div>`;
            });
            
            aiAnalysis.innerHTML = analysisHTML;
            aiAnalysis.style.display = 'block';
        }

        // Update stats
        function updateStats() {
            const aiCount = allComments.filter(comment => comment.isAi).length;
            const pendingCount = allComments.filter(comment => comment.status === 'pending').length;
            
            document.getElementById('totalComments').textContent = allComments.length;
            document.getElementById('pendingComments').textContent = pendingCount;
            document.getElementById('aiGenerated').textContent = aiCount;
        }

        // Filter button event listeners
        showAll.addEventListener('click', function() {
            setActiveFilter('all');
            renderComments('all');
            aiAnalysis.style.display = 'none';
        });

        showAI.addEventListener('click', function() {
            setActiveFilter('ai');
            renderComments('ai');
            showAIAnalysis();
        });

        showHuman.addEventListener('click', function() {
            setActiveFilter('human');
            renderComments('human');
            aiAnalysis.style.display = 'none';
        });

        function setActiveFilter(filter) {
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            
            if (filter === 'all') showAll.classList.add('active');
            else if (filter === 'ai') showAI.classList.add('active');
            else if (filter === 'human') showHuman.classList.add('active');
            
            currentFilter = filter;
        }

        // Delete comment
        function deleteComment(id) {
            if (confirm('Are you sure you want to delete this comment?')) {
                db.collection('comments').doc(id).delete()
                    .then(() => {
                        loadComments(currentFilter);
                    })
                    .catch(error => {
                        console.error('Error deleting comment:', error);
                        alert(`Error deleting comment: ${error.message}`);
                    });
            }
        }

        // Approve comment
        function approveComment(id) {
            db.collection('comments').doc(id).update({
                status: 'approved'
            })
            .then(() => {
                loadComments(currentFilter);
            })
            .catch(error => {
                console.error('Error approving comment:', error);
                alert(`Error approving comment: ${error.message}`);
            });
        }

        // Format timestamp
        function formatTime(timestamp) {
            const now = new Date();
            const diffMs = now - timestamp;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins} min ago`;
            
            const diffHours = Math.floor(diffMins / 60);
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            
            return timestamp.toLocaleDateString();
        }

        // Load stats (compatibility function)
        function loadStats() {
            loadComments(currentFilter);
        }

        // Function to ensure sentence completeness
        function ensureCompleteSentence(text) {
            // Remove incomplete trailing phrases
            const problematicEndings = [
                /,\s*and$/i,
                /,\s*but$/i,
                /,\s*yet$/i,
                /,\s*as$/i,
                /,\s*which$/i,
                /,\s*that$/i,
                /,\s*while$/i,
                /,\s*where$/i,
                /\s+to$/i,
                /\s+in$/i,
                /\s+of$/i,
                /\s+for$/i,
                /\s+with$/i,
                /\s+by$/i,
                /\s+from$/i
            ];
            
            // Check for problematic endings and truncate if found
            for (let pattern of problematicEndings) {
                if (pattern.test(text)) {
                    text = text.replace(pattern, '');
                    break;
                }
            }
            
            // Ensure it ends with proper punctuation
            if (!/[.!?]$/.test(text.trim())) {
                text = text.trim() + '.';
            }
            
            return text.trim();
        }

        // FIXED AI comment generation - no self-identification, complete sentences
        async function generateAiComment(apiKey) {
            localStorage.setItem('openaiApiKey', apiKey);
            
            // Ensure prompt diversity
            if (usedPrompts.length >= promptTemplates.length) {
                usedPrompts = [];
            }
            
            const availablePrompts = promptTemplates.filter(p => !usedPrompts.includes(p.type));
            const selectedPrompt = availablePrompts[Math.floor(Math.random() * availablePrompts.length)];
            
            usedPrompts.push(selectedPrompt.type);
            if (usedPrompts.length > promptTemplates.length / 2) {
                usedPrompts.shift();
            }
            
            // Multi-layer randomness selection
            const reactionContext = realVisitorReactions[Math.floor(Math.random() * realVisitorReactions.length)];
            const selectedPersona = visitorPersonas[Math.floor(Math.random() * visitorPersonas.length)];
            const timeContext = timeContexts[Math.floor(Math.random() * timeContexts.length)];
            
            // Adjusted AI parameters for complete sentences
            const dynamicTemperature = 0.75 + (Math.random() * 0.25); // 0.75-1.0 (more controlled)
            const dynamicMaxTokens = 80 + Math.floor(Math.random() * 20); // 80-100 (longer for completeness)
            
            const enhancedPrompt = `
You are experiencing "You're Live to the World" at the Royal College of Art - a contemporary art exhibition examining digital domesticity, surveillance culture, and the transformation of private space into public performance.

Exhibition elements:
- Miniature domestic environments on industrial scaffolding by Luca George
- Live green screen performances by Yaqi Sun exploring mediated domesticity
- Commentary on social media's transformation of home into content
- Investigation of privacy, surveillance, and digital infrastructure

Current observation/feeling: "${reactionContext}"

Context: This is during a ${timeContext.replace(/_/g, ' ')}.

${selectedPrompt.template}

CRITICAL REQUIREMENTS:
- Write ONLY 1-2 complete sentences maximum
- DO NOT identify yourself by profession, background, or role (no "As a student...", "As someone who...", etc.)
- Let your perspective come through naturally in your language choice, not through self-identification
- End with a complete thought - no hanging sentences
- Be specific about what you observe in the exhibition
- Use present tense and personal perspective ("I notice...", "This makes me think...", "The work...")
- Avoid academic jargon and art-speak
- Sound like a genuine visitor's immediate reaction

Your comment:`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4',
                    messages: [
                        { 
                            role: "system", 
                            content: `You are writing a brief visitor comment for a contemporary art exhibition. Write from the perspective of someone who ${selectedPersona.background}, but DO NOT explicitly state your background or role. Let your expertise level show through your language and observations naturally. Use a ${selectedPersona.language} approach. Be thoughtful and observant but avoid self-referential phrases like "As a..." or "Being someone who...". Focus on the work, not on yourself. Always complete your thoughts fully.`
                        },
                        { role: "user", content: enhancedPrompt }
                    ],
                    temperature: dynamicTemperature,
                    max_tokens: dynamicMaxTokens,
                    presence_penalty: 0.2,
                    frequency_penalty: 0.2,
                    stop: null // Allow natural completion
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error.message);
            }
            
            let generatedText = data.choices[0].message.content.trim().replace(/^["']|["']$/g, '');
            
            // Post-processing to ensure completeness
            generatedText = ensureCompleteSentence(generatedText);
            
            return {
                text: generatedText,
                promptType: selectedPrompt.type,
                visitorPersona: selectedPersona.type,
                timeContext: timeContext,
                reactionContext: reactionContext
            };
        }

        // Event handlers
        generatePreview.addEventListener('click', async function() {
            const apiKey = openaiApiKey.value.trim();
            if (!apiKey) {
                aiPreview.textContent = 'Please enter your OpenAI API key first';
                return;
            }
            
            generatePreview.textContent = 'GENERATING...';
            generatePreview.disabled = true;
            
            try {
                const result = await generateAiComment(apiKey);
                const randomName = visitorNames[Math.floor(Math.random() * visitorNames.length)];
                
                aiPreview.innerHTML = `
                    <strong>Fixed Preview:</strong><br>
                    <strong>Type:</strong> ${result.promptType.replace(/_/g, ' ')}<br>
                    <strong>Persona:</strong> ${result.visitorPersona.replace(/_/g, ' ')}<br>
                    <strong>Context:</strong> ${result.timeContext.replace(/_/g, ' ')}<br>
                    <strong>${randomName}:</strong> ${result.text}
                `;
            } catch (error) {
                aiPreview.textContent = `Error: ${error.message}`;
            } finally {
                generatePreview.textContent = 'Generate Preview';
                generatePreview.disabled = false;
            }
        });

        generateBatch.addEventListener('click', async function() {
            const apiKey = openaiApiKey.value.trim();
            if (!apiKey) {
                alert('Please enter your OpenAI API key first');
                return;
            }
            
            generateBatch.textContent = 'GENERATING...';
            generateBatch.disabled = true;
            
            try {
                aiPreview.innerHTML = '<strong>Generating 5 fixed comments...</strong><br><br>';
                
                for (let i = 0; i < 5; i++) {
                    const result = await generateAiComment(apiKey);
                    const randomName = visitorNames[Math.floor(Math.random() * visitorNames.length)];
                    
                    // Add to database
                    await db.collection('comments').add({
                        name: randomName,
                        text: result.text,
                        timestamp: firebase.firestore.Timestamp.now(),
                        status: 'approved',
                        isAi: true,
                        promptType: result.promptType,
                        visitorPersona: result.visitorPersona,
                        timeContext: result.timeContext,
                        reactionContext: result.reactionContext
                    });
                    
                    aiPreview.innerHTML += `${i + 1}. [${result.promptType.replace(/_/g, ' ')}|${result.visitorPersona.replace(/_/g, ' ')}] <strong>${randomName}:</strong> ${result.text}<br><br>`;
                    
                    // Delay between generations
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                aiPreview.innerHTML += '<em>All fixed comments added successfully!</em>';
                loadComments(currentFilter);
                
            } catch (error) {
                aiPreview.textContent = `Error: ${error.message}`;
            } finally {
                generateBatch.textContent = 'Generate 5 Comments';
                generateBatch.disabled = false;
            }
        });

        // Test diversity
        testDiversity.addEventListener('click', async function() {
            const apiKey = openaiApiKey.value.trim();
            if (!apiKey) {
                alert('Please enter your OpenAI API key first');
                return;
            }
            
            testDiversity.textContent = 'TESTING...';
            testDiversity.disabled = true;
            
            try {
                aiPreview.innerHTML = '<strong>Testing fixed diversity with 10 samples:</strong><br><br>';
                const usedTypes = new Set();
                const usedPersonas = new Set();
                
                for (let i = 0; i < 10; i++) {
                    const result = await generateAiComment(apiKey);
                    const randomName = visitorNames[Math.floor(Math.random() * visitorNames.length)];
                    
                    usedTypes.add(result.promptType);
                    usedPersonas.add(result.visitorPersona);
                    aiPreview.innerHTML += `${i + 1}. [${result.promptType.replace(/_/g, ' ')}|${result.visitorPersona.replace(/_/g, ' ')}] <strong>${randomName}:</strong> ${result.text}<br><br>`;
                    
                    await new Promise(resolve => setTimeout(resolve, 1200));
                }
                
                aiPreview.innerHTML += `<em>Used ${usedTypes.size} different prompt types and ${usedPersonas.size} different personas. All sentences complete!</em>`;
                
            } catch (error) {
                aiPreview.textContent = `Error: ${error.message}`;
            } finally {
                testDiversity.textContent = 'Test Diversity (10 samples)';
                testDiversity.disabled = false;
            }
        });

        // Auto-generation with randomized timing
        enableAiComments.addEventListener('click', function() {
            const apiKey = openaiApiKey.value.trim();
            if (!apiKey) {
                alert('Please enter your OpenAI API key first');
                return;
            }
            
            if (aiInterval) {
                // Disable AI comments
                clearTimeout(aiInterval);
                aiInterval = null;
                enableAiComments.textContent = 'Enable Auto Generation';
                enableAiComments.style.background = '#4CAF50';
                aiPreview.innerHTML = 'Auto-generation disabled.';
            } else {
                // Enable AI comments with randomized timing
                enableAiComments.textContent = 'Disable Auto Generation';
                enableAiComments.style.background = '#f44336';
                aiPreview.innerHTML = 'Fixed auto-generation enabled! Comments will be generated every 15-25 minutes with no self-identification and complete sentences.';
                
                // Generate first comment immediately
                generateAndPostAiComment();
                
                // Schedule next comment with random interval
                scheduleNextComment();
            }
        });

        // Schedule next comment with randomized timing
        function scheduleNextComment() {
            // Random interval between 15-25 minutes (900000-1500000 ms)
            const minInterval = 15 * 60 * 1000; // 15 minutes
            const maxInterval = 25 * 60 * 1000; // 25 minutes
            const randomInterval = minInterval + Math.random() * (maxInterval - minInterval);
            
            aiInterval = setTimeout(() => {
                generateAndPostAiComment();
                scheduleNextComment(); // Schedule the next one
            }, randomInterval);
            
            const nextInMinutes = Math.round(randomInterval / 60000);
            console.log(`Next AI comment scheduled in ${nextInMinutes} minutes`);
        }

        // Generate and post AI comment automatically
        async function generateAndPostAiComment() {
            const apiKey = openaiApiKey.value.trim();
            
            try {
                const result = await generateAiComment(apiKey);
                
                // Random visitor name
                const randomName = visitorNames[Math.floor(Math.random() * visitorNames.length)];
                
                // Add to database with enhanced metadata
                await db.collection('comments').add({
                    name: randomName,
                    text: result.text,
                    timestamp: firebase.firestore.Timestamp.now(),
                    status: 'approved',
                    isAi: true,
                    promptType: result.promptType,
                    visitorPersona: result.visitorPersona,
                    timeContext: result.timeContext,
                    reactionContext: result.reactionContext
                });
                
                console.log(`Auto-generated fixed comment (${result.promptType}|${result.visitorPersona}):`, result.text);
                
                // Reload comments if currently viewing
                if (currentFilter !== 'human') {
                    loadComments(currentFilter);
                }
                
            } catch (error) {
                console.error('Error generating auto comment:', error);
            }
        }

        // Auto-save API key
        openaiApiKey.addEventListener('change', function() {
            localStorage.setItem('openaiApiKey', this.value);
        });
    </script>
</body>
</html>
